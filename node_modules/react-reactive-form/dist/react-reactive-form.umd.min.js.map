{"version":3,"file":"react-reactive-form.umd.min.js","sources":["../src/observable.js","../src/utils.js","../src/validators.js","../src/model.js","../src/formBuilder.js","../src/Field.js","../src/configureControl.js","../src/FieldGroup.js","../src/FieldControl.js","../src/FieldArray.js","../src/FormGenerator.js"],"sourcesContent":["export default class Observable {\n  constructor() {\n    this.observers = []\n  }\n  subscribe(fn) {\n    this.observers.push(fn)\n  }\n  unsubscribe(fn) {\n    if (fn) {\n      this.observers = this.observers.filter(item => {\n        if (item !== fn) {\n          return item\n        }\n        return null\n      })\n    } else {\n      this.observers = []\n    }\n  }\n  next(o, thisObj) {\n    var scope = thisObj || window\n    this.observers.forEach(function(item) {\n      item.call(scope, o)\n    })\n  }\n}\n","import Observable from \"./observable\";\n\n/** Converts a promise into Observable\n * @param {Promise} r\n * @param {(value: any) => any} cb\n * @returns {Observable}\n */\nexport function fromPromise(r, cb) {\n  const observable = new Observable();\n  r.then(\n    value => {\n      const mappedValue = value => (cb ? cb(value) : value);\n      observable.next(mappedValue(value));\n    },\n    error => {\n      observable.next(error);\n    }\n  ).then(null, error => {\n    throw error;\n  });\n  return observable;\n}\n/**\n * Checks if an object is a Promise\n * @param {Observable} obj\n * @returns {boolean}\n */\nexport function isPromise(obj) {\n  return !!obj && typeof obj.then === \"function\";\n}\n/**\n * Checks if an object is a Function\n * @param {any} obj\n * @returns {boolean}\n */\nexport function isFunction(obj) {\n  return \"function\" === typeof obj;\n}\n/**\n * Checks if an object is Observable\n * @param {Observable} obj\n * @returns {boolean}\n */\nexport function isObservable(obj) {\n  return !!obj && typeof obj.subscribe === \"function\";\n}\n/**\n * Converts an object into Observable\n * @param {any} r\n * @returns {Observable}\n */\nexport function toObservable(r) {\n  const obs = isPromise(r) ? fromPromise(r) : r;\n  if (!isObservable(obs)) {\n    throw new Error(\"Expected validator to return Promise or Observable.\");\n  }\n  return obs;\n}\nexport const isReactNative = () =>\n  typeof window !== \"undefined\" &&\n  window.navigator &&\n  window.navigator.product &&\n  window.navigator.product === \"ReactNative\";\nexport const isEvent = candidate =>\n  !!(candidate && candidate.stopPropagation && candidate.preventDefault);\n\n// Common props\nexport const propsToBeMap = {\n  value: \"value\",\n  touched: \"touched\",\n  untouched: \"untouched\",\n  disabled: \"disabled\",\n  enabled: \"enabled\",\n  invalid: \"invalid\",\n  valid: \"valid\",\n  pristine: \"pristine\",\n  dirty: \"dirty\",\n  errors: \"errors\",\n  hasError: \"hasError\",\n  getError: \"getError\",\n  status: \"status\",\n  pending: \"pending\",\n  pendingValue: \"_pendingValue\"\n};\nexport const controlsToBeMap = {\n  ReactNative: {\n    switch: {\n      value: \"value\",\n      onValueChange: \"onChange\",\n      onBlur: \"onBlur\",\n      onFocus: \"onFocus\",\n      disabled: \"disabled\"\n    },\n    default: {\n      value: \"value\",\n      onChange: \"onChange\",\n      onBlur: \"onBlur\",\n      onFocus: \"onFocus\",\n      editable: \"enabled\"\n    }\n  },\n  default: {\n    value: \"value\",\n    onChange: \"onChange\",\n    onBlur: \"onBlur\",\n    onFocus: \"onFocus\",\n    disabled: \"disabled\"\n  }\n};\nexport const getAbsoluteValue = value =>\n  value === undefined || value === null ? \"\" : value;\n\nexport const getInputControls = inputType =>\n  isReactNative()\n    ? controlsToBeMap.ReactNative[inputType] ||\n      controlsToBeMap.ReactNative.default\n    : controlsToBeMap.default;\n\nexport function getHandler(inputType, value, control) {\n  const controlObject = {};\n  const inputControls = getInputControls(inputType);\n  Object.keys(inputControls).forEach(key => {\n    let controlProperty = null;\n    if (key === \"value\") {\n      if (control.updateOn !== \"change\") {\n        controlProperty = getAbsoluteValue(control._pendingValue);\n      } else {\n        controlProperty = getAbsoluteValue(control.value);\n      }\n    } else {\n      controlProperty = control[inputControls[key]];\n    }\n    controlObject[key] = controlProperty;\n  });\n  const mappedObject = controlObject;\n  switch (inputType) {\n    case \"checkbox\":\n      mappedObject[\"checked\"] = !!mappedObject.value;\n      mappedObject[\"type\"] = inputType;\n      break;\n    case \"radio\":\n      mappedObject[\"checked\"] = mappedObject.value === value;\n      mappedObject.value = value;\n      mappedObject[\"type\"] = inputType;\n      break;\n    default:\n  }\n  return mappedObject;\n}\n/**\n * Display warning messages\n * @param {condition} any\n * @param {message} string\n * @returns {void}\n */\nexport function warning(condition, message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!condition) {\n      console.error(`Warning: ${message}`);\n    }\n  }\n}\n/**\n * Generates the unique key for react elements\n * @param {*} pre\n */\nexport const generateKey = pre => {\n  return `${pre}_${new Date().getTime()}`;\n};\n\nexport const FIELD_PROPS = [\n  \"strict\",\n  \"render\",\n  \"name\",\n  \"index\",\n  \"control\",\n  \"formState\",\n  \"options\",\n  \"parent\",\n  \"meta\"\n];\n\nexport const mapConfigToFieldProps = config => {\n  const props = {};\n  if (config) {\n    Object.keys(config).forEach(configKey => {\n      if (FIELD_PROPS.indexOf(configKey) > -1) {\n        props[configKey] = config[configKey];\n      }\n    });\n  }\n  return props;\n};\n","import { fromPromise } from './utils'\n\nfunction isEmptyInputValue(value) {\n  return value == null || value.length === 0\n}\nfunction isPresent(o) {\n  return o != null\n}\nfunction _mergeErrors(arrayOfErrors) {\n  const res = arrayOfErrors.reduce((res, errors) => {\n    return errors != null ? Object.assign({}, res, errors) : res\n  }, {})\n  return Object.keys(res).length === 0 ? null : res\n}\nfunction _executeValidators(control, validators) {\n  return validators.map(v => v(control))\n}\nfunction _executeAsyncValidators(control, validators) {\n  return validators.map(v => v(control))\n}\n\nconst EMAIL_REGEXP = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n\nexport default class Validators {\n  /**\n   * Validator that requires controls to have a value greater than a number.\n   */\n  static min(min) {\n    return control => {\n      if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n        return null // don't validate empty values to allow optional controls\n      }\n      const parsedValue = parseFloat(control.value)\n      return !isNaN(parsedValue) && parsedValue < min\n        ? { min: { min, actual: parsedValue } }\n        : null\n    }\n  }\n\n  /**\n   * Validator that requires controls to have a value less than a number.\n   */\n  static max(max) {\n    return control => {\n      if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {\n        return null // don't validate empty values to allow optional controls\n      }\n      const parsedValue = parseFloat(control.value)\n      return !isNaN(parsedValue) && parsedValue > max\n        ? { max: { max, actual: parsedValue } }\n        : null\n    }\n  }\n\n  /**\n   * Validator that requires controls to have a non-empty value.\n   */\n  static required(control) {\n    return isEmptyInputValue(control.value) ? { required: true } : null\n  }\n\n  /**\n   * Validator that requires control value to be true.\n   */\n  static requiredTrue(control) {\n    return control.value === true ? null : { required: true }\n  }\n\n  /**\n   * Validator that performs email validation.\n   */\n  static email(control) {\n    if (isEmptyInputValue(control.value)) {\n      return null\n    }\n    return EMAIL_REGEXP.test(control.value) ? null : { email: true }\n  }\n\n  /**\n   * Validator that requires controls to have a value of a minimum length.\n   */\n  static minLength(minLength) {\n    return control => {\n      if (isEmptyInputValue(control.value)) {\n        return null // don't validate empty values to allow optional controls\n      }\n      const length = control.value ? control.value.length : 0\n      return length < minLength\n        ? { minLength: { requiredLength: minLength, actualLength: length } }\n        : null\n    }\n  }\n\n  /**\n   * Validator that requires controls to have a value of a maximum length.\n   */\n  static maxLength(maxLength) {\n    return control => {\n      const length = control.value ? control.value.length : 0\n      return length > maxLength\n        ? { maxLength: { requiredLength: maxLength, actualLength: length } }\n        : null\n    }\n  }\n  /**\n   * Validator that requires a control to match a regex to its value.\n   */\n  static pattern(pattern) {\n    if (!pattern) return null\n    let regex\n    let regexStr\n    if (typeof pattern === 'string') {\n      regexStr = `^${pattern}$`\n      regex = new RegExp(regexStr)\n    } else {\n      regexStr = pattern.toString()\n      regex = pattern\n    }\n    return control => {\n      if (isEmptyInputValue(control.value)) {\n        return null // don't validate empty values to allow optional controls\n      }\n      return regex.test(control.value)\n        ? null\n        : { pattern: { requiredPattern: regexStr, actualValue: control.value } }\n    }\n  }\n  /**\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps.\n   * @param {(Function|null|undefined)[]|null} validators\n   * @return {Function|null}\n   */\n  static compose(validators) {\n    if (!validators) return null\n    const presentValidators = validators.filter(isPresent)\n    if (presentValidators.length === 0) return null\n    return control =>\n      _mergeErrors(_executeValidators(control, presentValidators))\n  }\n  /**\n   * Compose multiple async validators into a single function that returns the union\n   * of the individual error maps.\n   * @param {(Function|null|undefined)[]|null} validators\n   * @return {Function|null}\n   */\n  static composeAsync(validators) {\n    if (!validators) return null\n    const presentValidators = validators.filter(isPresent)\n    if (presentValidators.length === 0) return null\n    return control => {\n      const observables = _executeAsyncValidators(control, presentValidators)\n      return fromPromise(Promise.all(observables), _mergeErrors)\n    }\n  }\n}\n","import { toObservable, isEvent, getHandler, isReactNative } from \"./utils\";\nimport Subject from \"./observable\";\nimport Validators from \"./validators\";\n\nexport const FormHooks = \"change\" | \"blur\" | \"submit\";\n\n/**\n * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.\n */\nexport const VALID = \"VALID\";\n\n/**\n * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.\n */\nexport const INVALID = \"INVALID\";\n\n/**\n * Indicates that a FormControl is pending, i.e. that async validation is occurring and\n * errors are not yet available for the input value.\n */\nexport const PENDING = \"PENDING\";\n\n/**\n * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor\n * calculations of validity or value.\n */\nexport const DISABLED = \"DISABLED\";\n\n/**\n * Calculates the control's value according to the input type\n * @param {any} event\n * @return {any}\n */\nfunction getControlValue(event) {\n  if (isEvent(event)) {\n    switch (event.target.type) {\n      case \"checkbox\":\n        return event.target.checked;\n      case \"select-multiple\":\n        if (event.target.options) {\n          let options = event.target.options;\n          var value = [];\n          for (var i = 0, l = options.length; i < l; i++) {\n            if (options[i].selected) {\n              value.push(options[i].value);\n            }\n          }\n          return value;\n        }\n        return event.target.value;\n      default:\n        return isReactNative() ? event.nativeEvent.text : event.target.value;\n    }\n  }\n  return event;\n}\n/**\n * @param {AbstractControl} control\n * @param {(String|Number)[]|String} path\n * @param {String} delimiter\n */\nfunction _find(control, path, delimiter) {\n  if (path == null) return null;\n  if (!(path instanceof Array)) {\n    path = path.split(delimiter);\n  }\n  if (path instanceof Array && path.length === 0) return null;\n  return path.reduce((v, name) => {\n    if (v instanceof FormGroup) {\n      return v.controls[name] || null;\n    }\n    if (v instanceof FormArray) {\n      return v.at(name) || null;\n    }\n    return null;\n  }, control);\n}\n/**\n * @param {{validators: Function|Function[]|null, asyncValidators: Function|Function[]|null, updateOn: 'change' | 'blur' | 'submit'}} validatorOrOpts\n * @return {Boolean}\n */\nfunction isOptionsObj(validatorOrOpts) {\n  return (\n    validatorOrOpts != null &&\n    !Array.isArray(validatorOrOpts) &&\n    typeof validatorOrOpts === \"object\"\n  );\n}\n/**\n * @param {Function} validator\n * @return {Function}\n */\nfunction normalizeValidator(validator) {\n  if (validator.validate) {\n    return c => validator.validate(c);\n  }\n  return validator;\n}\n/**\n * @param {Function} validator\n * @return {Function}\n */\nfunction normalizeAsyncValidator(validator) {\n  if (validator.validate) {\n    return c => validator.validate(c);\n  }\n  return validator;\n}\n/**\n * @param {Function[]} validators\n * @return {Function|null}\n */\nfunction composeValidators(validators) {\n  return validators != null\n    ? Validators.compose(validators.map(normalizeValidator))\n    : null;\n}\n/**\n * @param {Function[]} validators\n * @return {Function|null}\n */\nfunction composeAsyncValidators(validators) {\n  return validators != null\n    ? Validators.composeAsync(validators.map(normalizeAsyncValidator))\n    : null;\n}\n\nfunction coerceToValidator(validatorOrOpts) {\n  const validator = isOptionsObj(validatorOrOpts)\n    ? validatorOrOpts.validators\n    : validatorOrOpts;\n  return Array.isArray(validator)\n    ? composeValidators(validator)\n    : validator || null;\n}\n\nfunction coerceToAsyncValidator(asyncValidator, validatorOrOpts) {\n  const origAsyncValidator = isOptionsObj(validatorOrOpts)\n    ? validatorOrOpts.asyncValidators\n    : asyncValidator;\n  return Array.isArray(origAsyncValidator)\n    ? composeAsyncValidators(origAsyncValidator)\n    : origAsyncValidator || null;\n}\n/**\n * This is the base class for `FormControl`, `FormGroup`, and\n * `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n */\nexport class AbstractControl {\n  /**\n   * @param {Function|null} validator\n   * @param {Function|null} asyncValidator\n   */\n\n  constructor(validator, asyncValidator) {\n    this.validator = validator;\n    this.asyncValidator = asyncValidator;\n    /**\n     * A control is marked `touched` once the user has triggered\n     * a `blur` event on it.\n     */\n    this.touched = false;\n    this.submitted = false;\n    /**\n     * A control is `pristine` if the user has not yet changed\n     * the value in the UI.\n     *\n     * Note that programmatic changes to a control's value will\n     * *not* mark it dirty.\n     */\n    this.pristine = true;\n    this.meta = {};\n    this._pendingChange = this.updateOn !== \"change\";\n    this._pendingDirty = false;\n    this._pendingTouched = false;\n    this._onDisabledChange = [];\n    this.hasError = this.hasError.bind(this);\n    this.getError = this.getError.bind(this);\n    this.reset = this.reset.bind(this);\n    this.get = this.get.bind(this);\n    this.patchValue = this.patchValue.bind(this);\n    this.setValue = this.setValue.bind(this);\n  }\n  /**\n   * Returns the update strategy of the `AbstractControl` (i.e.\n   * the event on which the control will update itself).\n   * Possible values: `'change'` (default) | `'blur'` | `'submit'`\n   */\n  get updateOn() {\n    return this._updateOn\n      ? this._updateOn\n      : this.parent\n        ? this.parent.updateOn\n        : \"change\";\n  }\n  /**\n   * A control is `dirty` if the user has changed the value\n   * in the UI.\n   *\n   * Note that programmatic changes to a control's value will\n   * *not* mark it dirty.\n   * @return {Boolean}\n   */\n  get dirty() {\n    return !this.pristine;\n  }\n  /**\n   * A control is `valid` when its `status === VALID`.\n   *\n   * In order to have this status, the control must have passed all its\n   * validation checks.\n   * @return {Boolean}\n   */\n  get valid() {\n    return this.status === VALID;\n  }\n  /**\n   * A control is `invalid` when its `status === INVALID`.\n   *\n   * In order to have this status, the control must have failed\n   * at least one of its validation checks.\n   * @return {Boolean}\n   */\n  get invalid() {\n    return this.status === INVALID;\n  }\n  /**\n   * A control is `pending` when its `status === PENDING`.\n   *\n   * In order to have this status, the control must be in the\n   * middle of conducting a validation check.\n   */\n  get pending() {\n    return this.status === PENDING;\n  }\n  /**\n   * The parent control.\n   * * @return {FormGroup|FormArray}\n   */\n  get parent() {\n    return this._parent;\n  }\n  /**\n   * A control is `untouched` if the user has not yet triggered\n   * a `blur` event on it.\n   * @return {Boolean}\n   */\n  get untouched() {\n    return !this.touched;\n  }\n  /**\n   * A control is `enabled` as long as its `status !== DISABLED`.\n   *\n   * In other words, it has a status of `VALID`, `INVALID`, or\n   * `PENDING`.\n   * @return {Boolean}\n   */\n  get enabled() {\n    return this.status !== DISABLED;\n  }\n  /**\n   * A control is disabled if it's status is `DISABLED`\n   */\n  get disabled() {\n    return this.status === DISABLED;\n  }\n  /**\n   * Retrieves the top-level ancestor of this control.\n   * @return {AbstractControl}\n   */\n  get root() {\n    let x = this;\n    while (x._parent) {\n      x = x._parent;\n    }\n    return x;\n  }\n  setInitialStatus() {\n    if (this.disabled) {\n      this.status = DISABLED;\n    } else {\n      this.status = VALID;\n    }\n  }\n  /**\n   * Disables the control. This means the control will be exempt from validation checks and\n   * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n   *\n   * If the control has children, all children will be disabled to maintain the model.\n   * @param {{onlySelf: Boolean, emitEvent: Boolean}} opts\n   * @return {void}\n   */\n  disable(opts = {}) {\n    this.status = DISABLED;\n    this.errors = null;\n    this._forEachChild(control => {\n      control.disable({\n        onlySelf: true\n      });\n    });\n    this._updateValue();\n\n    if (opts.emitEvent !== false) {\n      this.valueChanges.next(this.value);\n      this.statusChanges.next(this.status);\n      this.stateChanges.next();\n    }\n\n    this._updateAncestors(!!opts.onlySelf);\n    this._onDisabledChange.forEach(changeFn => changeFn(true));\n  }\n  /**\n   * Enables the control. This means the control will be included in validation checks and\n   * the aggregate value of its parent. Its status is re-calculated based on its value and\n   * its validators.\n   *\n   * If the control has children, all children will be enabled.\n   * @param {{onlySelf: Boolean, emitEvent: Boolean}} opts\n   * @return {void}\n   */\n  enable(opts = {}) {\n    this.status = VALID;\n    this._forEachChild(control => {\n      control.enable({\n        onlySelf: true\n      });\n    });\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: opts.emitEvent\n    });\n    this._updateAncestors(!!opts.onlySelf);\n    this._onDisabledChange.forEach(changeFn => changeFn(false));\n  }\n  /**\n   * Re-calculates the value and validation status of the control.\n   *\n   * By default, it will also update the value and validity of its ancestors.\n   * @param {{onlySelf: Boolean, emitEvent: Booelan}} options\n   */\n  updateValueAndValidity(options = {}) {\n    this.setInitialStatus();\n    this._updateValue();\n    const shouldValidate =\n      this.enabled && (this.updateOn !== \"submit\" || this.submitted);\n    if (shouldValidate) {\n      this._cancelExistingSubscription();\n      this.errors = this._runValidator();\n      this.status = this._calculateStatus();\n      if (this.status === VALID || this.status === PENDING) {\n        this._runAsyncValidator(true);\n      }\n    }\n    if (options.emitEvent !== false) {\n      this.valueChanges.next(this.value);\n      this.statusChanges.next(this.status);\n      this.stateChanges.next();\n    }\n    if (this.parent && !options.onlySelf) {\n      this.parent.updateValueAndValidity(options);\n    }\n  }\n  /**\n   * Marks the control as `touched`.\n   *\n   * This will also mark all direct ancestors as `touched` to maintain\n   * the model.\n   * @param {{onlySelf: Boolean, emitEvent: Boolean}} opts\n   * @return {void}\n   */\n  markAsTouched(opts = {}) {\n    this.touched = true;\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsTouched(opts);\n    }\n    if (opts.emitEvent) {\n      this.stateChanges.next();\n    }\n  }\n  /**\n   * Marks the control as `submitted`.\n   *\n   * If the control has any children, it will also mark all children as `submitted`\n   * @param {{emitEvent: Boolean}} opts\n   * @return {void}\n   */\n  markAsSubmitted(opts = {}) {\n    this.submitted = true;\n\n    this._forEachChild(control => {\n      control.markAsSubmitted();\n    });\n\n    if (opts.emitEvent !== false) {\n      this.stateChanges.next();\n    }\n  }\n  /**\n   * Marks the control as `unsubmitted`.\n   *\n   * If the control has any children, it will also mark all children as `unsubmitted`.\n   *\n   * @param {{emitEvent: Boolean}} opts\n   * @return {void}\n   */\n  markAsUnsubmitted(opts = {}) {\n    this.submitted = false;\n\n    this._forEachChild(control => {\n      control.markAsUnsubmitted({\n        onlySelf: true\n      });\n    });\n\n    if (opts.emitEvent !== false) {\n      this.stateChanges.next();\n    }\n  }\n  /**\n   * Marks the control as `pristine`.\n   *\n   * If the control has any children, it will also mark all children as `pristine`\n   * to maintain the model, and re-calculate the `pristine` status of all parent\n   * controls.\n   * @param {{onlySelf: Boolean, emitEvent: Boolean}} opts\n   * @return {void}\n   */\n  markAsPristine(opts = {}) {\n    this.pristine = true;\n    this._pendingDirty = false;\n    if (opts.emitEvent) {\n      this.stateChanges.next();\n    }\n    this._forEachChild(control => {\n      control.markAsPristine({\n        onlySelf: true\n      });\n    });\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n  /**\n   * Marks the control as `untouched`.\n   *\n   * If the control has any children, it will also mark all children as `untouched`\n   * to maintain the model, and re-calculate the `touched` status of all parent\n   * controls.\n   * @param {{onlySelf: Boolean, emitEvent: Boolean}} opts\n   * @return {void}\n   */\n  markAsUntouched(opts = {}) {\n    this.touched = false;\n    this._pendingTouched = false;\n    this._forEachChild(control => {\n      control.markAsUntouched({\n        onlySelf: true\n      });\n    });\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n    if (opts.emitEvent) {\n      this.stateChanges.next();\n    }\n  }\n  /**\n   * Marks the control as `dirty`.\n   *\n   * This will also mark all direct ancestors as `dirty` to maintain\n   * the model.\n   * @param {{onlySelf: Boolean, emitEvent: Boolean}} opts\n   * @return {void}\n   */\n  markAsDirty(opts = {}) {\n    this.pristine = false;\n    if (opts.emitEvent) {\n      this.stateChanges.next();\n    }\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsDirty(opts);\n    }\n  }\n  /**\n   * Marks the control as `pending`.\n   * @param {{onlySelf: Boolean}} opts\n   * @return {void}\n   */\n  markAsPending(opts = {}) {\n    this.status = PENDING;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsPending(opts);\n    }\n  }\n  /**\n   * Sets the synchronous validators that are active on this control.  Calling\n   * this will overwrite any existing sync validators.\n   * @param {Function|Function[]|null} newValidator\n   * @return {void}\n   */\n  setValidators(newValidator) {\n    this.validator = coerceToValidator(newValidator);\n  }\n  /**\n   * Sets the async validators that are active on this control. Calling this\n   * will overwrite any existing async validators.\n   */\n  setAsyncValidators(newValidator) {\n    this.asyncValidator = coerceToAsyncValidator(newValidator);\n  }\n  /**\n   * Sets errors on a form control.\n   *\n   * This is used when validations are run manually by the user, rather than automatically.\n   *\n   * Calling `setErrors` will also update the validity of the parent control.\n   *\n   * ### Example\n   *\n   * ```\n   * const login = new FormControl(\"someLogin\");\n   * login.setErrors({\n   *   \"notUnique\": true\n   * });\n   *\n   * ```\n   * @param {{onlySelf: boolean}} opts\n   * @return {void}\n   */\n  setErrors(errors, opts = {}) {\n    this.errors = errors;\n    this._updateControlsErrors(opts.emitEvent !== false);\n  }\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * Paths can be passed in as an array or a string delimited by a dot.\n   *\n   * To get a control nested within a `person` sub-group:\n   *\n   * * `this.form.get('person.name');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['person', 'name']);`\n   * @param {(String|Number)[]|String} path\n   * @return {AbstractControl|null}\n   */\n  get(path) {\n    return _find(this, path, \".\");\n  }\n  /**\n   * Returns error data if the control with the given path has the error specified. Otherwise\n   * returns null or undefined.\n   *\n   * If no path is given, it checks for the error on the present control.\n   * @param {String} errorCode\n   * @param {(String|Number)[]|String} path\n   */\n  getError(errorCode, path) {\n    const control = path ? this.get(path) : this;\n    return control && control.errors ? control.errors[errorCode] : null;\n  }\n  /**\n   * Returns true if the control with the given path has the error specified. Otherwise\n   * returns false.\n   *\n   * If no path is given, it checks for the error on the present control.\n   * @param {String} errorCode\n   * @param {(String|Number)[]|String} path\n   * @return {Booelan}\n   */\n  hasError(errorCode, path) {\n    return !!this.getError(errorCode, path);\n  }\n  /**\n   * Empties out the sync validator list.\n   */\n  clearValidators() {\n    this.validator = null;\n  }\n  /**\n   * Empties out the async validator list.\n   */\n  clearAsyncValidators() {\n    this.asyncValidator = null;\n  }\n  /**\n   * @param {FormGroup|FormArray} parent\n   * @return {Void}\n   */\n  setParent(parent) {\n    this._parent = parent;\n  }\n  /**\n   * @param {Boolean} onlySelf\n   */\n  _updateAncestors(onlySelf) {\n    if (this._parent && !onlySelf) {\n      this._parent.updateValueAndValidity();\n      this._parent._updatePristine();\n      this._parent._updateTouched();\n    }\n  }\n  /**\n   * @param {String} status\n   * @return {Booelan}\n   */\n  _anyControlsHaveStatus(status) {\n    return this._anyControls(control => control.status === status);\n  }\n  /**\n   * @return {String}\n   */\n  _calculateStatus() {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this.errors) return INVALID;\n    if (this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n  _runValidator() {\n    return this.validator ? this.validator(this) : null;\n  }\n  /**\n   * @param {Booelan} emitEvent\n   * @return {void}\n   */\n  _runAsyncValidator(emitEvent) {\n    if (this.asyncValidator) {\n      this.status = PENDING;\n      const obs = toObservable(this.asyncValidator(this));\n      this._asyncValidationSubscription = obs.subscribe(errors =>\n        this.setErrors(errors, {\n          emitEvent\n        })\n      );\n    }\n  }\n  _cancelExistingSubscription() {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n    }\n  }\n  /**\n   * @param {{onlySelf: boolean}} opts\n   * @return {void}\n   */\n  _updatePristine(opts = {}) {\n    this.pristine = !this._anyControlsDirty();\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n  /**\n   * @param {{onlySelf: boolean}} opts\n   * @return {void}\n   */\n  _updateTouched(opts = {}) {\n    this.touched = this._anyControlsTouched();\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n  /**\n   * @return {Boolean}\n   */\n  _anyControlsDirty() {\n    return this._anyControls(control => control.dirty);\n  }\n  _anyControlsUnsubmitted() {\n    return this._anyControls(control => !control.submitted);\n  }\n  /**\n   * @return {Boolean}\n   */\n  _anyControlsTouched() {\n    return this._anyControls(control => control.touched);\n  }\n  /**\n   * @param {Booelan} emitEvent\n   * @return {void}\n   */\n  _updateControlsErrors(emitEvent) {\n    this.status = this._calculateStatus();\n    if (emitEvent) {\n      this.statusChanges.next();\n      this.stateChanges.next();\n    }\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent);\n    }\n  }\n  _initObservables() {\n    this.valueChanges = new Subject();\n    this.statusChanges = new Subject();\n    this.stateChanges = new Subject();\n  }\n  // Abstarct Methods\n  /**\n   * @param {Function} cb\n   * @return {void}\n   */\n  _forEachChild(cb) {}\n  _updateValue() {}\n  _allControlsDisabled() {}\n  _anyControls() {}\n  reset(value, options) {}\n  setValue() {}\n  patchValue() {}\n  _registerOnCollectionChange(fn) {\n    this._onCollectionChange = fn;\n  }\n  /**\n   * @param {{validators: Function|Function[]|null, asyncValidators: Function|Function[]|null, updateOn: 'change' | 'blur' | 'submit'}} opts\n   * @return {Void}\n   */\n  _setUpdateStrategy(opts) {\n    if (isOptionsObj(opts) && opts.updateOn != null) {\n      this._updateOn = opts.updateOn;\n    }\n  }\n}\nexport class FormControl extends AbstractControl {\n  constructor(formState, validatorOrOpts, asyncValidator) {\n    super(\n      coerceToValidator(validatorOrOpts),\n      coerceToAsyncValidator(asyncValidator, validatorOrOpts)\n    );\n    this.formState = formState;\n    this.validatorsOrOpts = validatorOrOpts;\n    this._applyFormState(formState);\n    this._setUpdateStrategy(validatorOrOpts);\n    this._pendingChange = true;\n    this._pendingDirty = false;\n    this._pendingTouched = false;\n    /**\n     * A control is `active` when its focused.\n     */\n    this.active = false;\n    this.onValueChanges = new Subject();\n    this.onBlurChanges = new Subject();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: false\n    });\n    this._initObservables();\n    /**\n     * Called whenevers an onChange event triggers.\n     * Updates the control value according to the update strategy.\n     *\n     * @param {any} event\n     * @return {void}\n     */\n    this.onChange = event => {\n      const value = getControlValue(event);\n      const isDirty = value !== this.value;\n      if (this.updateOn !== \"change\") {\n        this._pendingValue = value;\n        this._pendingChange = true;\n        if (isDirty && !this._pendingDirty) {\n          this._pendingDirty = true;\n        }\n        this.stateChanges.next();\n      } else {\n        if (isDirty && !this.dirty) {\n          this.markAsDirty();\n        }\n        this.setValue(value);\n      }\n      this.onValueChanges.next(value);\n    };\n    /**\n     * Called whenevers an onBlur event triggers.\n     */\n\n    this.onBlur = () => {\n      this.active = false;\n      if (this.updateOn === \"blur\") {\n        if (this._pendingDirty && !this.dirty) {\n          this.markAsDirty();\n        }\n        if (!this.touched) {\n          this.markAsTouched();\n        }\n        this.setValue(this._pendingValue);\n      } else if (this.updateOn === \"submit\") {\n        this._pendingTouched = true;\n      } else {\n        const emitChangeToView = !this.touched;\n        if (!this.touched) {\n          this.markAsTouched();\n        }\n        if (emitChangeToView) {\n          this.stateChanges.next();\n        }\n      }\n      this.onBlurChanges.next(this._pendingValue);\n    };\n    /**\n     * Called whenevers an onFocus event triggers.\n     */\n    this.onFocus = () => {\n      this.active = true;\n      this.stateChanges.next();\n    };\n    /**\n     * Returns the required props to bind an input element.\n     * @param {string} inputType\n     * @param {any} value\n     */\n    this.handler = (inputType, value) => getHandler(inputType, value, this);\n  }\n  /**\n   * A control is `inactive` when its not focused.\n   * @return {Boolean}\n   */\n  get inactive() {\n    return !this.active;\n  }\n  /**\n   * @param {{onlySelf: Boolean, emitEvent: Boolean}} options\n   * @return {void}\n   */\n  setValue(value, options = {}) {\n    this.value = this._pendingValue = value;\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * Patches the value of a control.\n   *\n   * This function is functionally the same as setValue at this level.\n   * It exists for symmetry with patchValue on `FormGroups` and\n   * `FormArrays`, where it does behave differently.\n   * @param {any} value\n   * @param {{onlySelf: Boolean, emitEvent: Boolean}} options\n   * @return {void}\n   */\n  patchValue(value, options = {}) {\n    this.setValue(value, options);\n  }\n\n  /**\n   * @param {{onlySelf: Boolean, emitEvent: Boolean}} options\n   * @return {void}\n   */\n  reset(formState = null, options = {}) {\n    this._applyFormState(formState);\n    this.markAsPristine(options);\n    this.markAsUntouched(options);\n    this.setValue(this.value, options);\n    this._pendingChange = false;\n  }\n  /**\n   * @param {Function} condition\n   * @return {Boolean}\n   */\n  _anyControls(condition) {\n    return false;\n  }\n  /**\n   * @return {Boolean}\n   */\n  _allControlsDisabled() {\n    return this.disabled;\n  }\n  /**\n   * @return {Boolean}\n   */\n  _isBoxedValue(formState) {\n    return (\n      typeof formState === \"object\" &&\n      formState !== null &&\n      Object.keys(formState).length === 2 &&\n      \"value\" in formState &&\n      \"disabled\" in formState\n    );\n  }\n  _applyFormState(formState) {\n    if (this._isBoxedValue(formState)) {\n      this.value = this._pendingValue = formState.value;\n      if (formState.disabled) {\n        this.disable({\n          onlySelf: true,\n          emitEvent: false\n        });\n      } else {\n        this.enable({\n          onlySelf: true,\n          emitEvent: false\n        });\n      }\n    } else {\n      this.value = this._pendingValue = formState;\n    }\n  }\n  _syncPendingControls() {\n    if (this.updateOn === \"submit\") {\n      if (this._pendingDirty) this.markAsDirty();\n      if (this._pendingTouched) this.markAsTouched();\n      if (this._pendingChange) {\n        this.setValue(this._pendingValue);\n        this._pendingChange = false;\n        return true;\n      }\n    }\n    return false;\n  }\n}\nexport class FormGroup extends AbstractControl {\n  constructor(controls, validatorOrOpts, asyncValidator) {\n    super(\n      coerceToValidator(validatorOrOpts),\n      coerceToAsyncValidator(asyncValidator, validatorOrOpts)\n    );\n    this.controls = controls;\n    this.validatorOrOpts = validatorOrOpts;\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: false\n    });\n    this.handleSubmit = e => {\n      if (e) {\n        e.preventDefault();\n      }\n      if (this._anyControlsUnsubmitted()) {\n        this.markAsSubmitted({\n          emitEvent: false\n        });\n      }\n      if (!this._syncPendingControls()) {\n        this.updateValueAndValidity();\n      }\n    };\n  }\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * It will return false for disabled controls. If you'd like to check for existence in the group\n   * only, use `AbstractControl` get instead.\n   * @param {String} controlName\n   * @return {Boolean}\n   */\n  contains(controlName) {\n    return (\n      this.controls.hasOwnProperty(controlName) &&\n      this.controls[controlName].enabled\n    );\n  }\n  /**\n   * Registers a control with the group's list of controls.\n   *\n   * This method does not update the value or validity of the control, so for most cases you'll want\n   * to use addControl instead.\n   * @param {String} name\n   * @param {AbstractControl} control\n   * @return {AbstractControl}\n   */\n  registerControl(name, control) {\n    if (this.controls[name]) return this.controls[name];\n    this.controls[name] = control;\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n    return control;\n  }\n\n  /**\n   * Add a control to this group.\n   * @param {String} name\n   * @param {AbstractControl} control\n   * @return {void}\n   */\n  addControl(name, control) {\n    this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Remove a control from this group.\n   * @param {String} name\n   * @return {void}\n   */\n  removeControl(name) {\n    if (this.controls[name])\n      this.controls[name]._registerOnCollectionChange(() => {});\n    delete this.controls[name];\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Replace an existing control.\n   * @param {String} name\n   * @param {AbstractControl} control\n   * @return {void}\n   */\n  setControl(name, control) {\n    if (this.controls[name])\n      this.controls[name]._registerOnCollectionChange(() => {});\n    delete this.controls[name];\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n  /**\n   * Sets the value of the FormGroup. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * This method performs strict checks, so it will throw an error if you try\n   * to set the value of a control that doesn't exist or if you exclude the\n   * value of a control.\n   *\n   *  ### Example\n   *  form.setValue({first: 'Jon', last: 'Snow'});\n   *  console.log(form.value);   // {first: 'Jon', last: 'Snow'}\n   * @param {{[key: string]: any}} value\n   * @param {{onlySelf: boolean, emitEvent: boolean}} options\n   * @return {void}\n   */\n  setValue(value, options = {}) {\n    this._checkAllValuesPresent(value);\n    Object.keys(value).forEach(name => {\n      this._throwIfControlMissing(name);\n      this.controls[name].setValue(value[name], {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * Resets the `FormGroup`.\n   * @param {any} value\n   * @param {{onlySelf: boolean, emitEvent: boolean}} options\n   * @return {void}\n   */\n  reset(value = {}, options = {}) {\n    this._forEachChild((control, name) => {\n      control.reset(value[name], {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this.updateValueAndValidity(options);\n    this.markAsUnsubmitted();\n    this._updatePristine(options);\n    this._updateTouched(options);\n  }\n  /**\n   *  Patches the value of the FormGroup. It accepts an object with control\n   *  names as keys, and will do its best to match the values to the correct controls\n   *  in the group.\n   *\n   *  It accepts both super-sets and sub-sets of the group without throwing an error.\n   *\n   *  ### Example\n   *  ```\n   *  console.log(form.value);   // {first: null, last: null}\n   *\n   *  form.patchValue({first: 'Jon'});\n   *  console.log(form.value);   // {first: 'Jon', last: null}\n   *\n   *  ```\n   * @param {{[key: string]: any}} value\n   * @param {{onlySelf: boolean, emitEvent: boolean}} options\n   * @return {void}\n   */\n  patchValue(value, options = {}) {\n    Object.keys(value).forEach(name => {\n      if (this.controls[name]) {\n        this.controls[name].patchValue(value[name], {\n          onlySelf: true,\n          emitEvent: options.emitEvent\n        });\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * The aggregate value of the FormGroup, including any disabled controls.\n   *\n   * If you'd like to include all values regardless of disabled status, use this method.\n   * Otherwise, the `value` property is the best way to get the value of the group.\n   */\n  getRawValue() {\n    return this._reduceChildren({}, (acc, control, name) => {\n      acc[name] =\n        control instanceof FormControl ? control.value : control.getRawValue();\n      return acc;\n    });\n  }\n  /**\n   * @param {{(v: any, k: String) => void}} callback\n   * @return {void}\n   */\n  _forEachChild(callback) {\n    Object.keys(this.controls).forEach(k => callback(this.controls[k], k));\n  }\n\n  _onCollectionChange() {}\n  /**\n   * @param {Function} condition\n   * @return {Boolean}\n   */\n  _anyControls(condition) {\n    let res = false;\n    this._forEachChild((control, name) => {\n      res = res || (this.contains(name) && condition(control));\n    });\n    return res;\n  }\n  _updateValue() {\n    this.value = this._reduceValue();\n  }\n  _reduceValue() {\n    return this._reduceChildren({}, (acc, control, name) => {\n      if (control.enabled || this.disabled) {\n        acc[name] = control.value;\n      }\n      return acc;\n    });\n  }\n  _reduceErrors() {\n    return this._reduceChildren({}, (acc, control, name) => {\n      if (control.enabled || this.disabled) {\n        acc[name] = control.errors;\n      }\n      return acc;\n    });\n  }\n  /**\n   * @param {Function} fn\n   */\n  _reduceChildren(initValue, fn) {\n    let res = initValue;\n    this._forEachChild((control, name) => {\n      res = fn(res, control, name);\n    });\n    return res;\n  }\n  _setUpControls() {\n    this._forEachChild(control => {\n      control.setParent(this);\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n  /**\n   * @return {Boolean}\n   */\n  _allControlsDisabled() {\n    for (const controlName of Object.keys(this.controls)) {\n      if (this.controls[controlName].enabled) {\n        return false;\n      }\n    }\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n  _checkAllValuesPresent(value) {\n    this._forEachChild((control, name) => {\n      if (value[name] === undefined) {\n        throw new Error(\n          `Must supply a value for form control with name: '${name}'.`\n        );\n      }\n    });\n  }\n  _throwIfControlMissing(name) {\n    if (!Object.keys(this.controls).length) {\n      throw new Error(`\n        There are no form controls registered with this group yet.\n      `);\n    }\n    if (!this.controls[name]) {\n      throw new Error(`Cannot find form control with name: ${name}.`);\n    }\n  }\n  _syncPendingControls() {\n    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {\n      return child._syncPendingControls() ? true : updated;\n    });\n    if (subtreeUpdated) this.updateValueAndValidity();\n    return subtreeUpdated;\n  }\n}\nexport class FormArray extends AbstractControl {\n  constructor(controls, validatorOrOpts, asyncValidator) {\n    super(\n      coerceToValidator(validatorOrOpts),\n      coerceToAsyncValidator(asyncValidator, validatorOrOpts)\n    );\n    this.controls = controls;\n    this.validatorOrOpts = validatorOrOpts;\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: false\n    });\n    this.handleSubmit = e => {\n      if (e) {\n        e.preventDefault();\n      }\n      if (this._anyControlsUnsubmitted()) {\n        this.markAsSubmitted({\n          emitEvent: false\n        });\n      }\n      if (!this._syncPendingControls()) {\n        this.updateValueAndValidity();\n      }\n    };\n  }\n  /**\n   * Get the `AbstractControl` at the given `index` in the array.\n   * @param {Number} index\n   * @return {AbstractControl}\n   */\n  at(index) {\n    return this.controls[index];\n  }\n\n  /**\n   * Insert a new `AbstractControl` at the end of the array.\n   * @param {AbstractControl} control\n   * @return {Void}\n   */\n  push(control) {\n    this.controls.push(control);\n    this._registerControl(control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Insert a new `AbstractControl` at the given `index` in the array.\n   * @param {Number} index\n   * @param {AbstractControl} control\n   */\n  insert(index, control) {\n    this.controls.splice(index, 0, control);\n    this._registerControl(control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Remove the control at the given `index` in the array.\n   * @param {Number} index\n   */\n  removeAt(index) {\n    if (this.controls[index])\n      this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Replace an existing control.\n   * @param {Number} index\n   * @param {AbstractControl} control\n   */\n  setControl(index, control) {\n    if (this.controls[index])\n      this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n\n    if (control) {\n      this.controls.splice(index, 0, control);\n      this._registerControl(control);\n    }\n\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Length of the control array.\n   * @return {Number}\n   */\n  get length() {\n    return this.controls.length;\n  }\n\n  /**\n   * Sets the value of the `FormArray`. It accepts an array that matches\n   * the structure of the control.\n   * @param {any[]} value\n   * @param {{onlySelf?: boolean, emitEvent?: boolean}} options\n   */\n  setValue(value, options = {}) {\n    this._checkAllValuesPresent(value);\n    value.forEach((newValue, index) => {\n      this._throwIfControlMissing(index);\n      this.at(index).setValue(newValue, {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   *  Patches the value of the `FormArray`. It accepts an array that matches the\n   *  structure of the control, and will do its best to match the values to the correct\n   *  controls in the group.\n   * @param {any[]} value\n   * @param {{onlySelf?: boolean, emitEvent?: boolean}} options\n   */\n  patchValue(value, options = {}) {\n    value.forEach((newValue, index) => {\n      if (this.at(index)) {\n        this.at(index).patchValue(newValue, {\n          onlySelf: true,\n          emitEvent: options.emitEvent\n        });\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormArray`.\n   * @param {any[]} value\n   * @param {{onlySelf?: boolean, emitEvent?: boolean}} options\n   */\n  reset(value = [], options = {}) {\n    this._forEachChild((control, index) => {\n      control.reset(value[index], {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this.updateValueAndValidity(options);\n    this.markAsUnsubmitted();\n    this._updatePristine(options);\n    this._updateTouched(options);\n  }\n\n  /**\n   * The aggregate value of the array, including any disabled controls.\n   *\n   * If you'd like to include all values regardless of disabled status, use this method.\n   * Otherwise, the `value` property is the best way to get the value of the array.\n   * @return {any[]}\n   */\n  getRawValue() {\n    return this.controls.map(control => {\n      return control instanceof FormControl\n        ? control.value\n        : control.getRawValue();\n    });\n  }\n\n  _syncPendingControls() {\n    let subtreeUpdated = this.controls.reduce((updated, child) => {\n      return child._syncPendingControls() ? true : updated;\n    }, false);\n    if (subtreeUpdated) this.updateValueAndValidity();\n    return subtreeUpdated;\n  }\n\n  _throwIfControlMissing(index) {\n    if (!this.controls.length) {\n      throw new Error(`\n        There are no form controls registered with this array yet.\n      `);\n    }\n    if (!this.at(index)) {\n      throw new Error(`Cannot find form control at index ${index}`);\n    }\n  }\n\n  _forEachChild(cb) {\n    this.controls.forEach((control, index) => {\n      cb(control, index);\n    });\n  }\n\n  _updateValue() {\n    this.value = this.controls\n      .filter(control => control.enabled || this.disabled)\n      .map(control => control.value);\n  }\n\n  _anyControls(condition) {\n    return this.controls.some(control => control.enabled && condition(control));\n  }\n\n  _setUpControls() {\n    this._forEachChild(control => this._registerControl(control));\n  }\n\n  _checkAllValuesPresent(value) {\n    this._forEachChild((control, i) => {\n      if (value[i] === undefined) {\n        throw new Error(`Must supply a value for form control at index: ${i}.`);\n      }\n    });\n  }\n\n  _allControlsDisabled() {\n    for (const control of this.controls) {\n      if (control.enabled) return false;\n    }\n    return this.controls.length > 0 || this.disabled;\n  }\n\n  _registerControl(control) {\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n  }\n\n  _onCollectionChange() {}\n}\n","import { FormControl, FormArray, FormGroup } from './model'\n\nfunction _createControl(controlConfig) {\n  if (\n    controlConfig instanceof FormControl ||\n    controlConfig instanceof FormGroup ||\n    controlConfig instanceof FormArray\n  ) {\n    return controlConfig\n  } else if (Array.isArray(controlConfig)) {\n    const value = controlConfig[0]\n    const validator = controlConfig.length > 1 ? controlConfig[1] : null\n    const asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null\n    const updateOn = controlConfig.length > 3 ? controlConfig[3] : null\n    return FormBuilder.control(value, validator, asyncValidator, updateOn)\n  }\n  return FormBuilder.control(controlConfig)\n}\nfunction _reduceControls(controlsConfig) {\n  const controls = {}\n  Object.keys(controlsConfig).forEach(controlName => {\n    controls[controlName] = _createControl(controlsConfig[controlName])\n  })\n  return controls\n}\nexport default class FormBuilder {\n  /**\n   * Construct a new `FormGroup` with the given map of configuration.\n   * Valid keys for the `extra` parameter map are `validators`, `asyncValidators` & `updateOn`.\n   * @param {{[key: string]: any}} controlsConfig\n   * @param {{[key: string]: any}|null} extra\n   * @return {FormGroup}\n   */\n  static group(controlsConfig, extra) {\n    const controls = _reduceControls(controlsConfig)\n    const validators = extra != null ? extra.validators : null\n    const asyncValidators = extra != null ? extra.asyncValidators : null\n    const updateOn = extra != null ? extra.updateOn : null\n    return new FormGroup(controls, { validators, asyncValidators, updateOn })\n  }\n  /**\n   * Construct a `FormArray` from the given `controlsConfig` array of\n   * Valid keys for the `extra` parameter map are `validators`, `asyncValidators` & `updateOn`.\n   */\n  static array(controlsConfig, extra) {\n    const controls = controlsConfig.map(c => _createControl(c))\n    const validators = extra != null ? extra.validators : null\n    const asyncValidators = extra != null ? extra.asyncValidators : null\n    const updateOn = extra != null ? extra.updateOn : null\n    return new FormArray(controls, { validators, asyncValidators, updateOn })\n  }\n\n  /**\n   * Construct a new `FormControl` with the given `formState`,`validator`,`asyncValidator`\n   * and `updateOn`\n   * `formState` can either be a standalone value for the form control or an object\n   * that contains both a value and a disabled status.\n   * @param {Object} formState\n   * @param {Function|Function[]|null} validator\n   * @param {Function|Function[]|null} asyncValidator\n   * @param {string} updatOn\n   * @return {FormControl}\n   */\n  static control(formState, validators, asyncValidators, updateOn) {\n    return new FormControl(formState, { validators, asyncValidators, updateOn })\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { FormControl, FormArray, FormGroup } from './model'\nimport { isFunction, warning } from './utils'\n\nexport default class Field extends React.Component {\n  componentDidMount() {\n    const { control } = this.props\n    // Add listener\n    this.addListener(control)\n  }\n  componentDidUpdate(prevProps) {\n    const { control } = this.props\n    if (control !== prevProps.control) {\n      this.removeListener(control)\n      this.addListener(control)\n    }\n  }\n  addListener(control) {\n    if (control) {\n      control.stateChanges.subscribe(() => {\n        this.forceUpdate()\n      })\n    }\n  }\n  removeListener(control) {\n    if (control) {\n      if (control.stateChanges.observers) {\n        control.stateChanges.observers.forEach(observer => {\n          control.stateChanges.unsubscribe(observer)\n        })\n      }\n    }\n  }\n  componentWillUnmount() {\n    const { control } = this.props\n    // Remove Listener\n    this.removeListener(control)\n  }\n  shouldComponentUpdate(props) {\n    if (!props.strict) {\n      return true\n    }\n    return false\n  }\n  getComponent() {\n    const { render, children, control } = this.props\n    warning(\n      control,\n      `Missing Control.Please make sure that an instance of FormControl, FormGroup or FormArray must be passed as a control prop in the Field component`\n    )\n    if (control) {\n      // Render function as child\n      if (isFunction(children)) {\n        return children(control)\n      }\n      // Render function as render prop\n      if (isFunction(render)) {\n        return render(control)\n      }\n      return null\n    }\n    return null\n  }\n  render() {\n    return this.getComponent()\n  }\n}\n\nField.defaultProps = {\n  strict: true\n}\n\nField.propTypes = {\n  strict: PropTypes.bool,\n  control: PropTypes.oneOfType([\n    PropTypes.instanceOf(FormControl),\n    PropTypes.instanceOf(FormArray),\n    PropTypes.instanceOf(FormGroup)\n  ]).isRequired,\n  render: PropTypes.func\n}\n","import { FormGroup, FormArray, FormControl } from './model'\nimport { warning } from './utils'\n\nconst getControlFromReference = (reference, options, formState) => {\n  switch (reference) {\n    case 'FormGroup':\n      return new FormGroup({}, options)\n    case 'FormArray':\n      return new FormArray([], options)\n    case 'FormControl':\n      return new FormControl(formState, options)\n    default:\n      return null\n  }\n}\nconst configureControl = (props, context, reference) => {\n  const { name, parent, options, index, control, formState, meta } = props\n  const parentControl = parent || context.parentControl\n  let returnControl = null\n  if (control) {\n    if (reference === 'FormGroup' && control instanceof FormGroup) {\n      returnControl = control\n    } else if (reference === 'FormArray' && control instanceof FormArray) {\n      returnControl = control\n    } else if (reference === 'FormControl' && control instanceof FormControl) {\n      returnControl = control\n    } else {\n      warning(null, `Control should be an instance of ${reference}.`)\n    }\n  } else {\n    if (name) {\n      /**\n       * The presence of name prop signifies two things:-\n       * 1. The group control has to be added as a nested control i.e parent should be present.\n       * 2. Parent must be an instance of FormGroup\n       */\n      warning(\n        parentControl,\n        `Error in ${name} control: Missing parent control.\n             Please make sure that the component is wrapped in a FieldGroup or\n             you can explicitly pass a parent control as a parent prop.`\n      )\n      warning(\n        parentControl && parentControl instanceof FormGroup,\n        `Error in ${name} control: A name prop can only be used if the parent is an instance of FormGroup,\n             You can use the index prop instead of name, if the parent control is an instance of FormArray`\n      )\n      if (parentControl && parentControl instanceof FormGroup) {\n        /**\n         * Check the presence of the control, if a control is already present in the parent control\n         * then don't add a new control, return the same.\n         */\n        if (!parentControl.get(name)) {\n          parentControl.addControl(\n            name,\n            getControlFromReference(reference, options, formState)\n          )\n        } else {\n          // warning(null, `A control is already present with name ${name}.`)\n        }\n        returnControl = parentControl.get(name)\n      }\n    } else {\n      if (parentControl instanceof FormArray) {\n        /**\n         * If a index prop is defined then insert the control at a particular index otherwise\n         * push the control at the end of FormArray\n         */\n        const insertAtIndex =\n          index !== undefined ? index : parentControl.controls.length\n        parentControl.insert(\n          insertAtIndex,\n          getControlFromReference(reference, options, formState)\n        )\n        returnControl = parentControl.at(insertAtIndex)\n      } else {\n        // Create a new instance and return as control in case of FormArray and FormGroup\n        if (reference === 'FormGroup' || reference === 'FormArray') {\n          returnControl = getControlFromReference(reference, options, formState)\n        }\n      }\n    }\n  }\n  // Add the meta data about the control\n  if (returnControl && meta) {\n    returnControl.meta = meta\n  }\n  return returnControl\n}\n\nexport default configureControl\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { FormGroup, FormArray } from './model'\nimport Field from './Field'\nimport configureControl from './configureControl'\n\nclass FieldGroup extends React.Component {\n  constructor(props, context) {\n    super(props, context)\n    this.control = configureControl(props, context, 'FormGroup')\n  }\n  getChildContext() {\n    return {\n      parentControl: this.control\n    }\n  }\n  render() {\n    const { strict, children, render } = this.props\n    const FieldProps = {\n      control: this.control,\n      strict,\n      render: render || children || null\n    }\n    return React.createElement(Field, FieldProps)\n  }\n}\n\nFieldGroup.childContextTypes = {\n  parentControl: PropTypes.oneOfType([\n    PropTypes.instanceOf(FormArray),\n    PropTypes.instanceOf(FormGroup)\n  ])\n}\nFieldGroup.contextTypes = {\n  parentControl: PropTypes.oneOfType([\n    PropTypes.instanceOf(FormArray),\n    PropTypes.instanceOf(FormGroup)\n  ])\n}\n\nFieldGroup.defaultProps = {\n  strict: true\n}\n\nFieldGroup.propTypes = {\n  strict: PropTypes.bool,\n  render: PropTypes.func,\n  name: PropTypes.string,\n  index: PropTypes.number,\n  control: PropTypes.instanceOf(FormGroup),\n  options: PropTypes.shape({\n    validators: PropTypes.oneOfType([\n      PropTypes.func,\n      PropTypes.arrayOf(PropTypes.func)\n    ]),\n    asyncValidators: PropTypes.oneOfType([\n      PropTypes.func,\n      PropTypes.arrayOf(PropTypes.func)\n    ]),\n    updateOn: PropTypes.oneOf(['change', 'blur', 'submit'])\n  }),\n  parent: PropTypes.oneOfType([\n    PropTypes.instanceOf(FormArray),\n    PropTypes.instanceOf(FormGroup)\n  ]),\n  meta: PropTypes.object\n}\nexport default FieldGroup\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { FormControl, FormArray, FormGroup } from './model'\nimport configureControl from './configureControl'\nimport Field from './Field'\nexport default class FieldControl extends React.Component {\n  constructor(props, context) {\n    super(props, context)\n    this.control = configureControl(props, context, 'FormControl')\n  }\n  componentDidUpdate(prevProps) {\n    if (this.props.name !== prevProps.name) {\n      this.control = configureControl(this.props, this.context, 'FormControl')\n    }\n  }\n  render() {\n    const { strict, children, render } = this.props\n    const FieldProps = {\n      control: this.control,\n      strict,\n      render: render || children || null\n    }\n    return React.createElement(Field, FieldProps)\n  }\n}\n\nFieldControl.defaultProps = {\n  strict: true\n}\nFieldControl.propTypes = {\n  strict: PropTypes.bool,\n  render: PropTypes.func,\n  name: PropTypes.string,\n  index: PropTypes.number,\n  control: PropTypes.instanceOf(FormControl),\n  formState: PropTypes.oneOfType([\n    PropTypes.shape({\n      value: PropTypes.any,\n      disabled: PropTypes.bool\n    }),\n    PropTypes.any\n  ]),\n  options: PropTypes.shape({\n    validators: PropTypes.oneOfType([\n      PropTypes.func,\n      PropTypes.arrayOf(PropTypes.func)\n    ]),\n    asyncValidators: PropTypes.oneOfType([\n      PropTypes.func,\n      PropTypes.arrayOf(PropTypes.func)\n    ]),\n    updateOn: PropTypes.oneOf(['change', 'blur', 'submit'])\n  }),\n  parent: PropTypes.oneOfType([\n    PropTypes.instanceOf(FormArray),\n    PropTypes.instanceOf(FormGroup)\n  ]),\n  meta: PropTypes.object\n}\nFieldControl.contextTypes = {\n  parentControl: PropTypes.oneOfType([\n    PropTypes.instanceOf(FormArray),\n    PropTypes.instanceOf(FormGroup)\n  ])\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { FormGroup, FormArray } from './model'\nimport configureControl from './configureControl'\nimport Field from './Field'\n\nclass FieldArray extends React.Component {\n  constructor(props, context) {\n    super(props, context)\n    this.control = configureControl(props, context, 'FormArray')\n  }\n  getChildContext() {\n    return {\n      parentControl: this.control\n    }\n  }\n  render() {\n    const { strict, children, render } = this.props\n    const FieldProps = {\n      control: this.control,\n      strict,\n      render: render || children || null\n    }\n    return React.createElement(Field, FieldProps)\n  }\n}\nFieldArray.childContextTypes = {\n  parentControl: PropTypes.oneOfType([\n    PropTypes.instanceOf(FormArray),\n    PropTypes.instanceOf(FormGroup)\n  ])\n}\nFieldArray.contextTypes = {\n  parentControl: PropTypes.oneOfType([\n    PropTypes.instanceOf(FormArray),\n    PropTypes.instanceOf(FormGroup)\n  ])\n}\nFieldArray.defaultProps = {\n  strict: true\n}\n\nFieldArray.propTypes = {\n  strict: PropTypes.bool,\n  render: PropTypes.func,\n  name: PropTypes.string,\n  index: PropTypes.number,\n  control: PropTypes.instanceOf(FormArray),\n  options: PropTypes.shape({\n    validators: PropTypes.oneOfType([\n      PropTypes.func,\n      PropTypes.arrayOf(PropTypes.func)\n    ]),\n    asyncValidators: PropTypes.oneOfType([\n      PropTypes.func,\n      PropTypes.arrayOf(PropTypes.func)\n    ]),\n    updateOn: PropTypes.oneOf(['change', 'blur', 'submit'])\n  }),\n  parent: PropTypes.oneOfType([\n    PropTypes.instanceOf(FormArray),\n    PropTypes.instanceOf(FormGroup)\n  ]),\n  meta: PropTypes.object\n}\nexport default FieldArray\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport FieldControl from './FieldControl'\nimport FieldArray from './FieldArray'\nimport FieldGroup from './FieldGroup'\nimport Field from './Field'\nimport { FormGroup, FormArray } from './model'\nimport { warning, mapConfigToFieldProps, generateKey } from './utils'\nimport configureControl from './configureControl'\n\nconst FIELD_CONFIG_STRING = '$field_'\n\nexport default class FormGenerator extends React.Component {\n  constructor(props) {\n    super(props)\n    // Intiate the form property\n    this.form = null\n  }\n  componentDidMount() {\n    this.props.onMount(this.form)\n  }\n  componentDidUpdate() {\n    this.props.onMount(this.form)\n  }\n  shouldComponentUpdate(nextProps) {\n    // Only Re-renders for changes in field config\n    if (nextProps.fieldConfig !== this.props.fieldConfig) {\n      return true\n    }\n    return false\n  }\n  componentWillUnmount() {\n    const { onUnmount } = this.props\n    onUnmount()\n  }\n  // Create the form instance\n  configureForm(type = 'FormGroup') {\n    const { fieldConfig } = this.props\n    this.form = configureControl(fieldConfig, {}, type)\n  }\n  // Creates the control from fieldConfig.\n  setControl(configProps, key, name = null) {\n    // Map the props to be passed in Field\n    const propsToBePassed = mapConfigToFieldProps(configProps)\n    // Set the key\n    propsToBePassed.key = key\n    if (name) {\n      propsToBePassed.name = name\n    }\n    // Set the component for $field_\n    if (\n      (name && name.startsWith(FIELD_CONFIG_STRING)) ||\n      (typeof configProps.index === 'string' &&\n        configProps.index.startsWith(FIELD_CONFIG_STRING))\n    ) {\n      // Only subscribe when isStatic is false\n      if (configProps.isStatic === false) {\n        return React.createElement(\n          Field,\n          Object.assign({}, { control: this.form }, propsToBePassed)\n        )\n      }\n      return propsToBePassed.render()\n    }\n\n    if (configProps.controls) {\n      if (configProps.controls instanceof Array) {\n        // If controls is an array then configure FormArray\n        if (!this.form) {\n          this.configureForm('FormArray')\n          propsToBePassed.control = this.form\n        }\n        return React.createElement(\n          FieldArray,\n          Object.assign({}, propsToBePassed, {\n            render: () =>\n              configProps.controls.map((config, index) =>\n                this.setControl(config, `${key}_${index}`)\n              )\n          })\n        )\n      } else if (configProps.controls instanceof Object) {\n        // If controls is an object then configure FormGroup\n        if (!this.form) {\n          this.configureForm()\n          propsToBePassed.control = this.form\n        }\n        return React.createElement(\n          FieldGroup,\n          Object.assign({}, propsToBePassed, {\n            render: () =>\n              Object.keys(configProps.controls).map(key =>\n                this.setControl(configProps.controls[key], key, key)\n              )\n          })\n        )\n      } else {\n        warning(false, `Missing controls in fieldConfig.`)\n        return null\n      }\n    } else {\n      return React.createElement(FieldControl, propsToBePassed)\n    }\n  }\n  generateFields() {\n    // Reset the form instance\n    this.form = null\n    const { fieldConfig } = this.props\n    if (fieldConfig.controls) {\n      const fields = this.setControl(fieldConfig, generateKey('my_form'))\n      return fields\n    } else {\n      // Throw error\n      warning(false, `Missing controls in fieldConfig.`)\n      return null\n    }\n  }\n  render() {\n    const { fieldConfig } = this.props\n    if (fieldConfig) {\n      return this.generateFields()\n    }\n    return null\n  }\n}\n\nFormGenerator.propTypes = {\n  fieldConfig: PropTypes.shape({\n    controls: PropTypes.oneOfType([PropTypes.object, PropTypes.array])\n      .isRequired,\n    strict: PropTypes.bool,\n    render: PropTypes.func,\n    name: PropTypes.string,\n    index: PropTypes.number,\n    control: PropTypes.oneOfType([\n      PropTypes.instanceOf(FormArray),\n      PropTypes.instanceOf(FormGroup)\n    ]),\n    options: PropTypes.shape({\n      validators: PropTypes.oneOfType([\n        PropTypes.func,\n        PropTypes.arrayOf(PropTypes.func)\n      ]),\n      asyncValidators: PropTypes.oneOfType([\n        PropTypes.func,\n        PropTypes.arrayOf(PropTypes.func)\n      ]),\n      updateOn: PropTypes.oneOf(['change', 'blur', 'submit'])\n    }),\n    parent: PropTypes.oneOfType([\n      PropTypes.instanceOf(FormArray),\n      PropTypes.instanceOf(FormGroup)\n    ]),\n    meta: PropTypes.object\n  }).isRequired,\n  onMount: PropTypes.func,\n  onUnmount: PropTypes.func\n}\nFormGenerator.defaultProps = {\n  onMount: () => null,\n  onUnmount: () => null\n}\n"],"names":["Observable","observers","fn","push","this","filter","item","o","thisObj","scope","window","forEach","call","fromPromise","r","cb","observable","then","next","value","error","isFunction","obj","isReactNative","navigator","product","isEvent","candidate","stopPropagation","preventDefault","controlsToBeMap","getAbsoluteValue","getInputControls","ReactNative","inputType","default","FIELD_PROPS","isEmptyInputValue","length","isPresent","_mergeErrors","arrayOfErrors","res","reduce","errors","Object","assign","keys","EMAIL_REGEXP","Validators","min","control","parsedValue","parseFloat","isNaN","actual","max","required","test","email","minLength","requiredLength","actualLength","maxLength","pattern","regex","regexStr","RegExp","toString","requiredPattern","actualValue","validators","presentValidators","map","v","observables","Promise","all","VALID","INVALID","PENDING","DISABLED","isOptionsObj","validatorOrOpts","Array","isArray","normalizeValidator","validator","validate","c","normalizeAsyncValidator","coerceToValidator","compose","coerceToAsyncValidator","asyncValidator","origAsyncValidator","asyncValidators","composeAsync","AbstractControl","touched","submitted","pristine","meta","_pendingChange","updateOn","_pendingDirty","_pendingTouched","_onDisabledChange","hasError","bind","getError","reset","get","patchValue","setValue","disabled","status","opts","_forEachChild","disable","_updateValue","emitEvent","valueChanges","statusChanges","stateChanges","_updateAncestors","onlySelf","changeFn","enable","updateValueAndValidity","options","setInitialStatus","enabled","_cancelExistingSubscription","_runValidator","_calculateStatus","_runAsyncValidator","parent","_parent","markAsTouched","markAsSubmitted","markAsUnsubmitted","markAsPristine","_updatePristine","markAsUntouched","_updateTouched","markAsDirty","markAsPending","newValidator","_updateControlsErrors","path","delimiter","split","name","FormGroup","controls","FormArray","at","errorCode","_anyControls","_allControlsDisabled","_anyControlsHaveStatus","obs","subscribe","Error","toObservable","_asyncValidationSubscription","_this","setErrors","unsubscribe","_anyControlsDirty","_anyControlsTouched","dirty","Subject","_onCollectionChange","_updateOn","x","FormControl","formState","validatorsOrOpts","_applyFormState","_setUpdateStrategy","active","onValueChanges","onBlurChanges","_initObservables","onChange","event","target","type","checked","i","l","selected","nativeEvent","text","getControlValue","isDirty","_this2","_pendingValue","onBlur","emitChangeToView","onFocus","handler","controlObject","inputControls","controlProperty","key","mappedObject","getHandler","condition","_isBoxedValue","_setUpControls","handleSubmit","e","_this3","_anyControlsUnsubmitted","_syncPendingControls","controlName","hasOwnProperty","setParent","_registerOnCollectionChange","registerControl","_checkAllValuesPresent","_throwIfControlMissing","_this5","_reduceChildren","acc","getRawValue","callback","_this6","k","_this7","contains","_reduceValue","_this8","_this9","initValue","_this10","undefined","subtreeUpdated","updated","child","_this11","index","_registerControl","splice","newValue","_this13","_this14","some","_this15","_createControl","controlConfig","FormBuilder","controlsConfig","extra","Field","props","addListener","prevProps","removeListener","forceUpdate","observer","strict","render","children","getComponent","React","Component","defaultProps","propTypes","PropTypes","bool","oneOfType","instanceOf","isRequired","func","getControlFromReference","reference","configureControl","context","parentControl","returnControl","addControl","insertAtIndex","insert","FieldGroup","FieldProps","createElement","childContextTypes","contextTypes","string","number","shape","arrayOf","oneOf","object","FieldControl","any","FieldArray","FIELD_CONFIG_STRING","FormGenerator","form","onMount","nextProps","fieldConfig","onUnmount","configProps","propsToBePassed","config","indexOf","configKey","startsWith","isStatic","configureForm","setControl","Date","getTime","generateFields","array"],"mappings":"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"}